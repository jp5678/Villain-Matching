<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Bridge - Today's Villain Matching</title>
    <style>
        :root {
            --bg-dark: #05070a;
            --felt-green: #0a3d31;
            --gold: #d4af37;
            --gold-light: #f1d592;
            --white: #ffffff;
            --yellow: #ffd700;
            --red: #ff3b30;
            --neon-green: #2ecc71;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-dark);
            color: var(--white);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 30%, rgba(212, 175, 55, 0.08) 0%, transparent 70%);
            pointer-events: none;
            z-index: 0;
        }

        header {
            text-align: center;
            padding: 60px 20px 40px;
            z-index: 1;
        }

        header h1 {
            font-size: 2.8rem;
            font-weight: 900;
            letter-spacing: 5px;
            margin: 0;
            color: var(--gold);
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.4);
        }

        header .subtitle {
            font-size: 0.9rem;
            color: var(--gold-light);
            letter-spacing: 2px;
            font-weight: 600;
            margin-top: 10px;
            text-transform: uppercase;
        }

        .table-container {
            position: relative;
            width: 94%;
            max-width: 480px;
            aspect-ratio: 1.6 / 1;
            background-color: var(--felt-green);
            border: 18px solid #2c1a12;
            border-radius: 30px;
            box-shadow:
                0 25px 60px rgba(0, 0, 0, 0.9),
                inset 0 0 100px rgba(0, 0, 0, 0.7);
            margin-bottom: 45px;
            overflow: hidden;
            z-index: 1;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .table-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.08) 0%, transparent 60%);
            box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.4);
        }

        .controls {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: 50px;
            z-index: 2;
        }

        .main-btn {
            background: linear-gradient(135deg, var(--gold), #b38f2d);
            color: #1a1100;
            border: none;
            padding: 22px 55px;
            font-size: 1.3rem;
            font-weight: 900;
            border-radius: 60px;
            cursor: pointer;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5), 0 0 20px rgba(212, 175, 55, 0.3);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            text-transform: uppercase;
            min-width: 320px;
            /* ë¬¸êµ¬ê°€ ê¸¸ì–´ì§ˆ ìˆ˜ ìˆì–´ í­ì„ ì¡°ê¸ˆ ë„“í˜ */
        }

        .main-btn:active {
            transform: scale(0.94) translateY(4px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }

        .main-btn:disabled {
            filter: grayscale(1);
            opacity: 0.8;
            cursor: wait;
        }

        .sound-hint {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 15px;
            letter-spacing: 1px;
        }

        #results {
            width: 90%;
            max-width: 500px;
            padding-bottom: 80px;
            display: grid;
            gap: 18px;
        }

        .match-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%);
            border: 1px solid rgba(212, 175, 55, 0.15);
            border-radius: 20px;
            padding: 24px;
            opacity: 0;
            transform: scale(0.95) translateY(25px);
            animation: cardAppear 0.6s forwards cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        @keyframes cardAppear {
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 18px;
            font-size: 0.75rem;
            font-weight: 800;
            color: var(--gold);
            text-transform: uppercase;
            border-bottom: 1px solid rgba(212, 175, 55, 0.1);
            padding-bottom: 10px;
        }

        .match-body {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 15px 0;
        }

        .player-box {
            text-align: center;
            width: 42%;
        }

        .player-name {
            font-size: 1.35rem;
            font-weight: 800;
            color: var(--white);
            margin-bottom: 5px;
            letter-spacing: -0.5px;
        }

        .vs-badge {
            background: linear-gradient(135deg, #333, #111);
            padding: 6px 12px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 900;
            color: var(--gold);
            border: 1px solid var(--gold);
        }

        .comment-box {
            background: rgba(46, 204, 113, 0.1);
            border: 1px dashed rgba(46, 204, 113, 0.2);
            border-radius: 12px;
            padding: 12px;
            margin-top: 20px;
            text-align: center;
            font-size: 0.9rem;
            color: #afff60;
            font-style: italic;
            line-height: 1.4;
        }

        footer {
            padding: 50px;
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.8rem;
            line-height: 1.8;
            z-index: 1;
        }

        .glow {
            animation: neonGlow 2s infinite alternate;
        }

        @keyframes neonGlow {
            from {
                text-shadow: 0 0 10px var(--gold), 0 0 20px rgba(212, 175, 55, 0.2);
            }

            to {
                text-shadow: 0 0 20px var(--gold), 0 0 40px var(--gold-light);
            }
        }
    </style>
</head>

<body>

    <header>
        <div class="subtitle" style="opacity: 0.6;">EST. 2025</div>
        <h1 class="glow">THE BRIDGE</h1>
        <div class="subtitle">Today's Villain Matching</div>
    </header>

    <div class="table-container">
        <canvas id="billiardCanvas"></canvas>
        <div class="table-overlay"></div>
    </div>

    <div class="controls">
        <button class="main-btn" id="actionBtn" onclick="handleStart()">
            <span>ğŸ±</span> ìš´ëª…ì˜ íëŒ€ ëŒë¦¬ê¸°
        </button>
        <div class="sound-hint">â€» ì‚¬ìš´ë“œê°€ ì¼œì ¸ ìˆëŠ”ì§€ í™•ì¸í•´ ì£¼ì„¸ìš”</div>
    </div>

    <div id="results"></div>

    <footer>
        &copy; 2025 THE BRIDGE BILLIARDS CLUB<br>
        ëª¨ë“  ê¶Œí•œì€ ë” ë¸Œë¦¿ì§€ íšŒì›ë‹˜ë“¤ê»˜ ìˆìŠµë‹ˆë‹¤.
    </footer>

    <script>
        const members = [
            "ë°±ì‚¬6000", "ë ¤ë¦¬", "kbh", "ë°œì¹¸VULCAN",
            "ì§€êµ", "ë¬´ë“±ì‚°1329", "ì…ì„ëŒ€", "ì¼€ì´574",
            "ê·¸ë Œë‹¤ì´ì €", "SMG", "ë„ìœ ë‚˜ê°€ì¦ˆì•„", "ë©”ë¡±ìƒíƒœ"
        ];

        const comments = [
            "ì´ ë§¤ì¹­... ì‚¬ì‹¤ìƒ ê²°ìŠ¹ì „ ì•„ë‹Œê°€ìš”? ê´€ì „ í•„ìˆ˜!",
            "ë‹˜ì˜ í ëì´ ì‹¬ìƒì¹˜ ì•ŠìŠµë‹ˆë‹¤. ì¡°ì‹¬í•˜ì„¸ìš”!",
            "ì˜¤ëŠ˜ ì§€ëŠ” ë¶„ì´ ì‹œì›í•˜ê²Œ í•œ ì” ì˜ëŠ” ê°ì…ë‹ˆë‹¤.",
            "ì˜ˆìˆ êµ¬ì™€ ì •ì„êµ¬ì˜ í”¼í•  ìˆ˜ ì—†ëŠ” ì •ë©´ ìŠ¹ë¶€!",
            "ì˜¤ëŠ˜ì˜ ë¹ŒëŸ° í–¥ê¸°ê°€ ë¬¼ì”¬ í’ê¸°ëŠ” ì¡°í•©ì…ë‹ˆë‹¤.",
            "íŒ¨ìëŠ” ì¡°ìš©íˆ ì¹´ìš´í„°ë¡œ, ìŠ¹ìëŠ” ë‹¹êµ¬ëŒ€ì— ë‚¨ìœ¼ì„¸ìš”.",
            "ì‹¤ë ¥ ì°¨ì´ëŠ” ì¢…ì‡ì¥ í•œ ì¥ ì°¨ì´! ì •ì‹ ë ¥ì´ ìŠ¹íŒ¨ë¥¼ ê°€ë¦…ë‹ˆë‹¤.",
            "ë‘ ë¶„, ì–´ì œ ë‚¨ëª°ë˜ ì•¼ê°„ íŠ¹í›ˆí•˜ì‹  ê±° ë‹¤ ì†Œë¬¸ë‚¬ìŠµë‹ˆë‹¤.",
            "ì„¸ê¸°ì˜ ëŒ€ê²°! ì²« ì´ë‹ ì´ˆêµ¬ ì„±ê³µ ì—¬ë¶€ê°€ ê´€ê±´ì…ë‹ˆë‹¤.",
            "í ì¡ëŠ” ì†ì´ ë°”ë“¤ë°”ë“¤... ê¸´ì¥í•˜ë©´ ì§€ëŠ” ê²ë‹ˆë‹¤!"
        ];

        // ë‹¤ì‹œ ëŒë¦¬ê¸°ìš© ìœ„íŠ¸ ìˆëŠ” ë¬¸êµ¬ë“¤
        const retryPhrases = [
            "ì¸ì • ëª»í•´! íŒ ë‹¤ì‹œ ì§œê¸°",
            "íëŒ€ ë‹¤ì‹œ ì¡ê³  ë¦¬ë§¤ì¹˜",
            "ë¹ŒëŸ° ì¬ë°°ì¹˜ (ë³µìˆ˜ì „)",
            "ìš´ëª…ì˜ ì¥ë‚œ, ë‹¤ì‹œ í•œ ë²ˆ?",
            "ìƒˆë¡œìš´ í¬ìƒì–‘(?) ì°¾ê¸°",
            "ëŒ€ì§„í‘œê°€ ë§˜ì— ì•ˆ ë“¤ë©´ í´ë¦­",
            "í•œ íŒ ë”? (ì´ë²ˆì—” ì§„ì§œì„)",
            "ì¡°í•©ì´ ë§µë‹¤! ë‹¤ì‹œ ëŒë¦¬ê¸°"
        ];

        let audioCtx;
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playCollisionSound(intensity = 1) {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const volume = Math.min(intensity / 15, 0.3);
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = 'triangle';
            osc.frequency.setValueAtTime(160 + (Math.random() * 40), audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.1);

            gain.gain.setValueAtTime(volume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        function playSuccessSound() {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const now = audioCtx.currentTime;
            const notes = [523.25, 659.25, 783.99, 1046.50];

            notes.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, now + (i * 0.1));

                gain.gain.setValueAtTime(0.2, now + (i * 0.1));
                gain.gain.exponentialRampToValueAtTime(0.001, now + (i * 0.1) + 0.6);

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start(now + (i * 0.1));
                osc.stop(now + (i * 0.1) + 0.6);
            });
        }

        const canvas = document.getElementById('billiardCanvas');
        const ctx = canvas.getContext('2d');
        let balls = [];
        let animationId;
        let isSimulating = false;

        class Ball {
            constructor(x, y, vx, vy, color, label) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.radius = 10;
                this.color = color;
                this.label = label;
                this.friction = 0.996;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x + 3, this.y + 3, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.fill();

                const grad = ctx.createRadialGradient(
                    this.x - this.radius / 2.5, this.y - this.radius / 2.5, this.radius / 10,
                    this.x, this.y, this.radius
                );
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.3, this.color);
                grad.addColorStop(1, '#000');

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x - this.radius / 3, this.y - this.radius / 3, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.fill();
            }

            update() {
                if (!isSimulating) return;

                this.x += this.vx;
                this.y += this.vy;

                let hitWall = false;
                if (this.x + this.radius > canvas.width || this.x - this.radius < 0) {
                    this.vx = -this.vx;
                    this.x = this.x - this.radius < 0 ? this.radius : canvas.width - this.radius;
                    hitWall = true;
                }
                if (this.y + this.radius > canvas.height || this.y - this.radius < 0) {
                    this.vy = -this.vy;
                    this.y = this.y - this.radius < 0 ? this.radius : canvas.height - this.radius;
                    hitWall = true;
                }

                if (hitWall) {
                    playCollisionSound(Math.abs(this.vx) + Math.abs(this.vy));
                }

                this.vx *= this.friction;
                this.vy *= this.friction;

                balls.forEach(other => {
                    if (other === this) return;
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.radius + other.radius) {
                        const angle = Math.atan2(dy, dx);
                        const sin = Math.sin(angle);
                        const cos = Math.cos(angle);

                        const overlap = (this.radius + other.radius) - distance;
                        this.x -= (overlap / 2) * cos;
                        this.y -= (overlap / 2) * sin;
                        other.x += (overlap / 2) * cos;
                        other.y += (overlap / 2) * sin;

                        const v1 = { x: this.vx * cos + this.vy * sin, y: this.vy * cos - this.vx * sin };
                        const v2 = { x: other.vx * cos + other.vy * sin, y: other.vy * cos - other.vx * sin };

                        const temp = v1.x;
                        v1.x = v2.x;
                        v2.x = temp;

                        this.vx = v1.x * cos - v1.y * sin;
                        this.vy = v1.y * cos + v1.x * sin;
                        other.vx = v2.x * cos - v2.y * sin;
                        other.vy = v2.y * cos + v2.x * sin;

                        playCollisionSound(Math.abs(this.vx) + Math.abs(other.vx));
                    }
                });
            }
        }

        function initCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            balls = [
                new Ball(canvas.width * 0.2, canvas.height * 0.4, 0, 0, '#ffffff', 'W'),
                new Ball(canvas.width * 0.5, canvas.height * 0.6, 0, 0, '#ffd700', 'Y'),
                new Ball(canvas.width * 0.8, canvas.height * 0.4, 0, 0, '#ff3b30', 'R')
            ];
            render();
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke();
            }

            balls.forEach(ball => {
                ball.update();
                ball.draw();
            });
            animationId = requestAnimationFrame(render);
        }

        const loadingTexts = [
            "ìš´ëª…ì˜ ì´ˆì´ìŠ¤ ì§„í–‰ ì¤‘...",
            "ë¹ŒëŸ°ë“¤ì˜ ê¸°ìš´ì„ ë§¤ì¹­í•˜ê³  ìˆìŠµë‹ˆë‹¤...",
            "ë‘ê»˜ 1/4, íšŒì „ ë§¥ì‹œë©ˆ ì¡°ì ˆ ì¤‘...",
            "3ì¿ ì…˜ ê²½ë¡œë¥¼ ì •ë°€ ë¶„ì„ ì¤‘...",
            "ìš´ëª…ì˜ í ëì´ ë©ˆì¶”ë ¤ í•©ë‹ˆë‹¤...",
            "ê±°ì˜ ë‹¤ ì™”ìŠµë‹ˆë‹¤. ê¸´ì¥í•˜ì„¸ìš”!"
        ];

        function handleStart() {
            initAudio();
            const btn = document.getElementById('actionBtn');
            const resultsDiv = document.getElementById('results');

            btn.disabled = true;
            let textIdx = 0;
            btn.innerHTML = `<span>â³</span> ${loadingTexts[textIdx]}`;

            const textInterval = setInterval(() => {
                textIdx = (textIdx + 1) % loadingTexts.length;
                btn.innerHTML = `<span>â³</span> ${loadingTexts[textIdx]}`;
            }, 1400);

            resultsDiv.innerHTML = '';

            isSimulating = true;
            balls.forEach(ball => {
                ball.vx = (Math.random() - 0.5) * 16;
                ball.vy = (Math.random() - 0.5) * 16;
            });

            setTimeout(() => {
                clearInterval(textInterval);
                isSimulating = false;

                playSuccessSound();
                showResults();

                // ë²„íŠ¼ ë¬¸êµ¬ë¥¼ ë¬´ì‘ìœ„ë¡œ ë³€ê²½
                const randomPhrase = retryPhrases[Math.floor(Math.random() * retryPhrases.length)];
                btn.disabled = false;
                btn.innerHTML = `<span>ğŸ”„</span> ${randomPhrase}`;
            }, 8500);
        }

        function showResults() {
            const shuffled = [...members].sort(() => Math.random() - 0.5);
            const resultsDiv = document.getElementById('results');

            for (let i = 0; i < shuffled.length; i += 2) {
                const p1 = shuffled[i];
                const p2 = shuffled[i + 1];
                const comment = comments[Math.floor(Math.random() * comments.length)];

                const card = document.createElement('div');
                card.className = 'match-card';
                card.style.animationDelay = `${(i / 2) * 0.35}s`;

                card.innerHTML = `
                    <div class="match-header">
                        <span>BRIDGE MATCH ${i / 2 + 1}</span>
                        <span>OFFICIAL 2025</span>
                    </div>
                    <div class="match-body">
                        <div class="player-box">
                            <div class="player-name">${p1}</div>
                        </div>
                        <div class="vs-badge">VS</div>
                        <div class="player-box">
                            <div class="player-name">${p2}</div>
                        </div>
                    </div>
                    <div class="comment-box">${comment}</div>
                `;
                resultsDiv.appendChild(card);
            }

            setTimeout(() => {
                window.scrollTo({ top: resultsDiv.offsetTop - 40, behavior: 'smooth' });
            }, 400);
        }

        window.onload = initCanvas;
        window.onresize = initCanvas;
    </script>
</body>

</html>